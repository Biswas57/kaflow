# TributaryStream gRPC Service

This module provides a streaming gRPC interface for the Tributary message broker, enabling real-time message production and consumption over HTTP/2.

## Features

- **Bi-directional streaming for message production**: Clients can send a stream of messages and receive acknowledgments in real-time
- **Server streaming for message consumption**: Clients can subscribe to topics and receive messages as they arrive
- **Per-consumer-group offset management**: Maintains consumer group progress across rebalancing
- **Type-safe message serialization**: Uses Protocol Buffers with `google.protobuf.Any` for polymorphic payloads

## API Overview

### ProduceRequest
```proto3
message ProduceRequest {
  string producer_id  = 1;
  string topic_id     = 2;
  optional string partition_id = 3;             
  string payload_type      = 4;              // "string", "bytes", etc.
  bytes  key      = 5;             
  google.protobuf.Any payload   = 6;
}
```

### ProduceAck
```proto3
message ProduceAck {
  string message_id   = 1;              // generated by broker
  string partition_id = 2;
  bool   success      = 3;
  optional string error_msg    = 4;
}
```

### SubscribeRequest
```proto3
message SubscribeRequest {
  string consumer_id  = 1;        
  string group_id     = 2;
  optional string partition_id = 3;  // If specified, consume only from this partition
}
```

### Event
```proto3
message Event {
  string topic_id     = 1;
  string partition_id = 2;
  uint64 offset       = 3;
  google.protobuf.Any payload     = 4;
}
```

## Usage Examples

### Starting the Server

```java
TributaryController controller = new TributaryController();
TributaryStreamServer server = new TributaryStreamServer(9090, controller);
server.start();
server.blockUntilShutdown();
```

### Producing Messages

```java
TributaryStreamClient client = new TributaryStreamClient("localhost", 9090);

// Create a produce stream
StreamObserver<ProduceRequest> producer = client.asyncStub.produce(
    new StreamObserver<ProduceAck>() {
        @Override
        public void onNext(ProduceAck ack) {
            if (ack.getSuccess()) {
                System.out.println("Message produced: " + ack.getMessageId());
            } else {
                System.err.println("Production failed: " + ack.getErrorMsg());
            }
        }
        // ... other methods
    }
);

// Send messages
ProduceRequest message = ProduceRequest.newBuilder()
    .setProducerId("my-producer")
    .setTopicId("my-topic")
    .setPayloadType("string")
    .setKey(ByteString.copyFromUtf8("my-key"))
    .setPayload(Any.pack(StringValue.of("Hello, World!")))
    .build();

producer.onNext(message);
producer.onCompleted();
```

### Consuming Messages

```java
SubscribeRequest request = SubscribeRequest.newBuilder()
    .setConsumerId("my-consumer")
    .setGroupId("my-group")
    .build();

client.asyncStub.subscribe(request, new StreamObserver<Event>() {
    @Override
    public void onNext(Event event) {
        System.out.println("Received message from " + event.getTopicId() + 
                          " at offset " + event.getOffset());
        
        // Unpack payload
        if (event.getPayload().is(StringValue.class)) {
            String message = event.getPayload().unpack(StringValue.class).getValue();
            System.out.println("Message: " + message);
        }
    }
    // ... other methods
});
```

## Configuration

### Server Configuration

The server can be configured with:
- **Port**: gRPC server port (default: 9090)
- **Controller**: TributaryController instance for broker operations

### Client Configuration

The client connects to:
- **Host**: Server hostname (default: localhost)
- **Port**: Server port (default: 9090)

## Offset Management

The streaming service preserves the per-consumer-group offset management implemented in the core broker:

- Each consumer group maintains its own offset per partition
- Adding/removing consumers triggers rebalancing but preserves group progress
- Offsets are automatically incremented as messages are consumed
- Multiple consumer groups can consume from the same topic independently

## Error Handling

- **Production errors**: Returned via `ProduceAck.error_msg`
- **Consumption errors**: Propagated through gRPC error status
- **Network errors**: Handled by gRPC retry mechanisms
- **Consumer not found**: Results in gRPC INVALID_ARGUMENT error

## Performance Considerations

- **Polling interval**: Consumer polling runs every 100ms by default
- **Concurrent consumers**: Each subscription runs in its own thread
- **Message batching**: Individual messages are sent immediately (no batching)
- **Flow control**: Managed by gRPC's built-in flow control

## Testing

Run the integration tests to verify functionality:

```bash
./gradlew test --tests "tributary.stream.*"
```

The test suite includes:
- Message production and acknowledgment
- Message consumption and delivery
- End-to-end produce-consume workflows
- Error handling scenarios
